#!/usr/bin/python3

import subprocess
from os import path, listdir

"""
auto-generates test cases for compiler
then runs cargo-test

(couldn't get rust's macro system to create a function from a macro expression (only from an identifer))
"""

TESTS_DIR = 'tests/compiler_test_data/'
COMPILER_TESTS_FILE = 'tests/generated_compiler_tests.rs'

def get_test_categories():
    return {
        category: {
            'inputs': sorted(listdir(path.join(TESTS_DIR, category, 'inputs'))),
        } for category in listdir(TESTS_DIR) if not category.startswith('_')
    }


test_cases = get_test_categories()

categories, cases = zip(*[(category, inp[:inp.index('.c')]) for category, data in test_cases.items() for inp in data['inputs'] if not inp.startswith('_')])
# assert all([i.replace('.c', '') == t.replace('.res', '') for i, t in zip(inputs, targets)]), 'input/target mismatch!'


compiler_tests_code = """

// This file was auto-generated by run_tests.py
// some of the test cases are from: https://github.com/nlsandler/write_a_c_compiler/

extern crate simple_vm;
use simple_vm::operating_system::OS;
use simple_vm::operating_system::compiler::Compiler;

use std::io;
use std::fs::{self, DirEntry};
use std::path::Path;
use std::fs::File;
use std::io::prelude::*;
use std::io::Read;

#[derive(Debug)]
struct CompilerTestCase{
    category: String,
    input_f: String,
    target_res_f : Option<String>,
    target_out_f : Option<String>,
}

fn read_file_content(file_path: &str) -> String{
    let mut f = File::open(file_path).unwrap();
    let mut content = String::new();
    f.read_to_string(&mut content).unwrap();
    content
}

fn test_single(test_case: &CompilerTestCase){
    let mut os = OS::new();
    let program = os.compile(&test_case.input_f);
    let res = os.assemble_and_run(&program);
    let out = &os.out_chars.iter().map(|c| c.to_string()).collect::<Vec<String>>().join("");
    if let Some(res_f) = &test_case.target_res_f {
        let tar_res = read_file_content(res_f);
        println!("res: {},{}", res.to_string(), tar_res);
        assert_eq!(res.to_string(), tar_res.trim());
    }
    if let Some(out_f) = &test_case.target_out_f {
        let tar_out = read_file_content(out_f);
        println!("out: {},{}", out.to_string(), tar_out);
        assert_eq!(out.to_string(), tar_out.trim());
    }
}
"""

for cat, case in zip(categories, cases):
    target_res_fpath = path.join(TESTS_DIR, cat, 'targets', case + '.res')
    target_out_fpath = path.join(TESTS_DIR, cat, 'targets', case + '.out')
    assert any((path.isfile(target_res_fpath), path.isfile(target_out_fpath))), f"{cat}/{case} doesn't have any targets files"
    target_res_f = f"""Some("{target_res_fpath}".to_string()) """ if path.isfile(target_res_fpath) else "None"
    target_out_f = f"""Some("{target_out_fpath}".to_string()) """ if path.isfile(target_out_fpath) else "None"
    compiler_tests_code += \
    f"""
#[test]
fn test_{cat}_{case}(){{
    let case = CompilerTestCase{{
        category: "{cat}".to_string(),
        input_f: "{path.join(TESTS_DIR, cat, 'inputs', case + ".c")}".to_string(),
        target_res_f: {target_res_f},
        target_out_f: {target_out_f},
    }};
    test_single(&case);
}}
    """


with open(COMPILER_TESTS_FILE, 'w') as f:
    f.write(compiler_tests_code)

subprocess.run("cargo test", shell=True)